# Cursor Rules for Crypto Trader Project

## Project Context
This is a Rust-based cryptocurrency trading application using:
- Tokio for async runtime
- reqwest for HTTP requests
- serde/serde_json for serialization
- chrono for time handling
- anyhow/thiserror for error handling

## Code Style & Best Practices

### Rust Conventions
- Follow Rust 2021 edition conventions
- Use `snake_case` for variables, functions, and modules
- Use `PascalCase` for types and traits
- Prefer explicit error handling with `Result<T, E>` and `?` operator
- Use `anyhow::Result` for application-level errors, `thiserror::Error` for library-level errors
- Document public APIs with `///` doc comments
- Use expressive variable names that convey intent (e.g., `is_ready`, `has_data`, `has_position`)
- Avoid code duplication; use functions and modules to encapsulate reusable logic

### File Size & Modularity (CRITICAL)
- **Target file size**: 300-500 lines (ideal), 800 lines (acceptable), 1200 lines (maximum)
- **When a file exceeds 800 lines**: Break it into smaller modules following single-responsibility principle
- **Refactoring strategy for large files**:
  - Extract related functionality into separate modules
  - Group by responsibility: parsing, business logic, state management
  - Create helper modules (e.g., `helpers.rs`, `types.rs`, `traits.rs`)
  - Use `mod.rs` for module organization when appropriate
- **Examples of good splits**:
  - `parser.rs` ‚Üí `parser/mod.rs` + `parser/parse_orderbook.rs` + `parser/parse_trades.rs`
  - `strategy.rs` ‚Üí `strategy/mod.rs` + `strategy/signals.rs` + `strategy/position.rs`
  - `engine.rs` ‚Üí Split into `engine/mod.rs`, `engine/state.rs`, `engine/handlers.rs`

### Code Organization & Structure
- Keep modules focused and single-responsibility
- Use `mod.rs` or inline module definitions appropriately
- Group related functionality (api, models, strategy, indicators, screener, parser, utils)
- Separate concerns: networking, business logic, data structures
- Structure into clear module hierarchy:
  ```
  src/
  ‚îú‚îÄ‚îÄ module/
  ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs           # Public exports
  ‚îÇ   ‚îú‚îÄ‚îÄ types.rs         # Types and structs
  ‚îÇ   ‚îú‚îÄ‚îÄ handlers.rs      # Main logic
  ‚îÇ   ‚îî‚îÄ‚îÄ helpers.rs       # Helper functions
  ```

### Async Programming Patterns
- Use `tokio` as the async runtime
- Implement async functions using `async fn` syntax
- Leverage `tokio::spawn` for concurrent tasks
- Use `tokio::select!` for managing multiple async tasks and cancellations
- Favor structured concurrency: prefer scoped tasks and clean cancellation paths
- Implement timeouts, retries, and backoff strategies for robust async operations
- Use `tokio::time::sleep` and `tokio::time::interval` for efficient time-based operations
- Avoid blocking operations inside async functions; offload to dedicated blocking threads if necessary
- Use `tokio::task::yield_now` to yield control in cooperative multitasking scenarios

### Channels and Concurrency
- Use `tokio::sync::mpsc` for asynchronous, multi-producer, single-consumer channels
- Use `tokio::sync::broadcast` for broadcasting messages to multiple consumers
- Implement `tokio::sync::oneshot` for one-time communication between tasks
- Prefer bounded channels for backpressure; handle capacity limits gracefully
- Use `tokio::sync::Mutex` and `tokio::sync::RwLock` for shared state across tasks
- **Avoid**: `std::sync::Mutex` inside async tasks (use `tokio::sync::Mutex` instead)
- Minimize lock duration; prefer message passing over shared state when possible

### Error Handling and Safety
- Embrace Rust's `Result` and `Option` types for error handling
- Use `?` operator to propagate errors in async functions
- Implement custom error types using `thiserror` or `anyhow` for more descriptive errors
- Use `anyhow::Context` for adding context to errors: `.context("message")`
- Use `thiserror::Error` derive macro for structured error types
- Handle errors and edge cases early, returning errors where appropriate
- Use `.await` responsibly, ensuring safe points for context switching
- Log errors appropriately before returning or propagating

### API & Networking
- Use `reqwest` for HTTP requests with proper error handling
- Handle rate limits and retries appropriately
- Parse JSON responses safely with serde
- Use appropriate HTTP methods and headers
- Implement connection retry logic with exponential backoff

### Testing & Validation
- Write unit tests in `tests/` directory or inline with `#[cfg(test)]`
- Use `tokio::test` for async tests
- Use `tokio::time::pause` for testing time-dependent code without real delays
- Use `mockito` for mocking HTTP responses in integration tests
- Test error cases and edge conditions
- Implement integration tests to validate async behavior and concurrency
- **API Validation Tests**: Test credentials, balances, trade history before trading
- **Backtest Validation**: Validate strategy performance on historical data
- **Strategy Variants**: Test multiple strategy variants (trailing, early exit, extended target)
- **Performance Metrics**: Track win rate, Sharpe ratio, max drawdown, total P&L

### Performance Optimization
- Minimize async overhead; use sync code where async is not needed
- Avoid unnecessary allocations in hot paths
- Use `&str` over `String` when possible
- Consider using references to avoid cloning large data structures
- Profile before optimizing
- Optimize data structures and algorithms for async use, reducing contention
- Avoid heavy operations in critical paths (e.g., serde_json parsing, SystemTime::now in hot loops)

### Security
- Never hardcode API keys or secrets
- Use environment variables or config files for sensitive data
- Validate and sanitize all external inputs
- Handle financial calculations with appropriate precision
- Implement strict access controls where applicable

## Project-Specific Guidelines

### Module Structure
- Follow the existing module structure (api, models, strategy, indicators, screener, parser, utils, exchanges, execution)
- Each exchange integration in `src/exchanges/{exchange}/`
- Execution logic in `src/execution/`
- Keep configuration in `config/` directory
- Store data files in `data/` directory (which is gitignored)

### Incremental Development & Git Workflow
- **Make small, incremental changes** that can be committed frequently
- **Each commit should represent a working state** - code should compile and pass tests
- **Break large features into smaller commits**:
  - First: Add module structure and types
  - Second: Implement core logic
  - Third: Add error handling
  - Fourth: Add tests
  - Fifth: Integration and refinement
- **Commit message format**: Use clear, descriptive messages:
  ```
  feat: add RSI indicator calculation
  refactor: split engine.rs into smaller modules
  fix: correct stop-loss position tracking
  ```
- **Before refactoring large files**: Create a commit with current state, then refactor
- **Document significant changes** in commit messages or PR descriptions

### Refactoring Large Files
When encountering files > 800 lines:
1. **Analyze dependencies**: Identify what can be extracted
2. **Extract types first**: Move structs/enums to `types.rs`
3. **Extract helpers**: Move utility functions to `helpers.rs`
4. **Split by responsibility**: Group related functions into separate modules
5. **Update tests**: Ensure tests still work after refactoring
6. **Commit incrementally**: One module at a time

### Code Review Checklist
- [ ] File size under 1200 lines (preferably under 800)
- [ ] Clear module boundaries and responsibilities
- [ ] Async code uses `tokio::sync::Mutex` not `std::sync::Mutex`
- [ ] Error handling with proper context
- [ ] No blocking operations in async functions
- [ ] Tests for new functionality
- [ ] Documentation for public APIs

## When Making Changes

### Before Making Changes
- Review existing code patterns before making changes
- Check file sizes - if target file > 800 lines, consider refactoring first
- Identify similar functionality that can be reused
- Plan incremental changes that can be committed separately

### During Development
- Write clear, concise, and idiomatic Rust code
- Keep functions focused on single responsibility
- Extract complex logic into helper functions
- Use descriptive names that convey intent
- Add inline comments for complex logic

### After Making Changes
- Ensure code compiles and tests pass
- Update tests when changing functionality
- Document significant changes or new features
- Maintain backward compatibility when possible
- Consider if file size needs refactoring
- Commit in logical chunks

## Incremental Feature Development

When adding new features:
1. **Planning Phase**: Identify required modules and dependencies
2. **Foundation**: Create types and data structures (commit)
3. **Core Logic**: Implement main functionality in small chunks (multiple commits)
4. **Integration**: Wire up with existing systems (commit)
5. **Testing**: Add unit and integration tests (commit)
6. **Refinement**: Optimize and document (commit)

### Example: Adding New Indicator
1. `feat: add MACD indicator types` - Add struct and trait definitions
2. `feat: implement MACD calculation logic` - Core calculation in separate file
3. `feat: integrate MACD into strategy` - Connect to existing strategy
4. `test: add MACD unit tests` - Test calculations
5. `docs: document MACD indicator usage` - Update documentation

## Key Principles Summary

1. **Modularity**: Keep files small (300-500 lines ideal, 800 max recommended, 1200 hard limit)
2. **Single Responsibility**: Each module/file should do one thing well
3. **Incremental Development**: Small, frequent commits with working code
4. **Async Best Practices**: Use tokio primitives, avoid blocking in async
5. **Error Handling**: Proper error propagation with context
6. **Performance**: Profile before optimizing, avoid allocations in hot paths
7. **Security**: Never hardcode secrets, validate inputs
8. **Testing**: Test as you develop, not after

## Reducing Compilation Errors - Best Practices

### Modular Project Organization
- **Break code into small modules** - Each module should compile independently
- This reduces dependency chains and "error avalanches"
- Clear module boundaries: `mod.rs` for public interface, separate files for implementation
- Example structure:
  ```
  src/
  ‚îú‚îÄ‚îÄ module/
  ‚îÇ   ‚îú‚îÄ‚îÄ mod.rs           # Public exports only
  ‚îÇ   ‚îú‚îÄ‚îÄ types.rs         # Types and structs
  ‚îÇ   ‚îú‚îÄ‚îÄ handlers.rs      # Main logic
  ‚îÇ   ‚îî‚îÄ‚îÄ helpers.rs       # Helper functions
  ```

### Frequent Compilation Checks
- **Use `cargo check` frequently** - Checks code without building binaries
- Fix errors incrementally, don't wait for final build
- Run `cargo check` after each logical change:
  ```bash
  cargo check --features gate_exec
  ```
- This catches errors early and prevents "error snowball effect"

### Conscious Type Usage and Cloning
- **If object is moved but needed again - clone it explicitly**
- Rust cannot "guess" what you want - be explicit:
  ```rust
  // ‚ùå Bad - use after move
  self.position = Some(pos);
  self.entry_price = Some(pos.entry_price); // Error!
  
  // ‚úÖ Good - extract values first
  let entry = pos.entry_price;
  self.position = Some(pos);
  self.entry_price = Some(entry);
  
  // ‚úÖ Good - clone if needed multiple times
  let metrics = calculate_metrics(&trades);
  let cloned = metrics.clone();
  // Use metrics here, cloned later
  ```
- Add `#[derive(Clone)]` to structs that need cloning:
  ```rust
  #[derive(Debug, Clone)]
  pub struct PerformanceMetrics { ... }
  ```

### Feature Flags and Conditional Compilation
- **Use `#[cfg(feature = "...")]` for optional modules**
- Always compile with correct features:
  ```bash
  cargo check --features gate_exec
  cargo build --features gate_exec
  ```
- Document required features in module docs
- Use feature gates consistently:
  ```rust
  #![cfg(feature = "gate_exec")]
  // or
  #[cfg(feature = "gate_exec")]
  pub mod execution;
  ```

### Consistent Naming Conventions
- **Follow Rust conventions strictly:**
  - `snake_case` for functions, variables, modules
  - `PascalCase` for types, traits, structs, enums
  - `SCREAMING_SNAKE_CASE` for constants
  - `'short` for lifetimes
- Clear separation of interface (`mod.rs`) and implementation
- Use meaningful names that convey intent

### Error Prevention Checklist
1. ‚úÖ Run `cargo check` after each logical change
2. ‚úÖ Check for move errors before using `clone()`
3. ‚úÖ Verify all imports use correct module paths (`rust_test::` for binaries)
4. ‚úÖ Ensure feature flags are set correctly
5. ‚úÖ Remove unused imports and variables
6. ‚úÖ Fix warnings - Rust is strict about these
7. ‚úÖ Test compilation frequently, not just at the end

### Debugging Compilation Errors
- Read error messages carefully - Rust has excellent error messages
- Use `rustc --explain E0382` for detailed error explanations
- Check for common patterns:
  - E0382: use after move ‚Üí clone or restructure
  - E0255: duplicate names ‚Üí remove or rename
  - E0433: unresolved import ‚Üí check module path
  - E0425: function not found ‚Üí check imports/scope

## Project Integrations

### Gate.io Integration (rust-trade)
- **Location**: `rust-trade/trading-core/src/exchange/gateio.rs`
- **Status**: ‚úÖ Complete integration with WebSocket and REST API
- **Usage**: Use `GateioExchange` instead of `BinanceExchange` - implements same `Exchange` trait
- **Features**:
  - Real-time WebSocket trades subscription
  - Historical trades via REST API
  - Automatic reconnection and error handling
  - Format conversion: Gate.io ‚Üí TickData
- **Documentation**: See `rust-trade/GATEIO_INTEGRATION.md` and `rust-trade/QUICK_START.md`
- **Symbol format**: Accepts `BTCUSDT` (converts internally to `BTC_USDT` for Gate.io)

### Available Backtesting Projects
1. **rust-trade** (`rust-trade/`): Desktop app with Tauri + Next.js, PostgreSQL, Redis caching
   - Gate.io integration added
   - Visual backtesting interface
   - Real-time data collection

2. **barter-rs** (`barter-rs-main/`): High-performance algorithmic trading ecosystem (2k+ stars)
   - Modular architecture: Barter, Barter-Data, Barter-Execution, Barter-Integration
   - Fast backtesting with indexed data structures
   - Strategy and RiskManager components
   - Paper trading with live market data

### Choosing Backtesting Framework
- **rust-trade**: Best for visual interface, database-backed, full stack application
- **barter-rs**: Best for high-performance, modular, extensive strategy library

## PostgreSQL Database Integration

### Current Status
- **Feature Flag**: `database` (requires `gate_exec`)
- **Location**: `src/database/`
- **Status**: üöß In Progress - Integration started, compilation fixes needed

### Module Structure
```
src/database/
‚îú‚îÄ‚îÄ mod.rs          # Public exports
‚îú‚îÄ‚îÄ types.rs        # Database types (TickData, OHLCVData, BacktestResult, StrategyLog, etc.)
‚îî‚îÄ‚îÄ repository.rs   # DatabaseRepository - CRUD operations
```

### Schema
- **Location**: `database/schema.sql`
- **Tables**:
  - `tick_data` - Real-time trade data (timestamp, symbol, price, quantity, side, etc.)
  - `ohlcv_data` - Candlestick data (timestamp, symbol, interval, open/high/low/close/volume)
  - `backtest_results` - Strategy backtest results (P&L, ROI, win rate, profit factor, etc.)
  - `strategy_logs` - Detailed execution logs per strategy
  - `account_history` - Account balance snapshots

### Dependencies
- `sqlx = "0.7"` with features: `["runtime-tokio-native-tls", "postgres", "chrono", "rust_decimal", "uuid"]`
- `rust_decimal = "1.32"` with features: `["serde-with-str", "db-postgres"]`
- `chrono = "0.4"` with feature: `["serde"]`
- `thiserror = "1"` (optional, for RepositoryError)

### Usage
1. **Setup Database**:
   ```bash
   # See docs/DATABASE_SETUP.md for detailed instructions
   createdb cryptotrader
   psql cryptotrader < database/schema.sql
   ```

2. **Set Environment Variable**:
   ```bash
   export DATABASE_URL="postgresql://user:password@localhost:5432/cryptotrader"
   ```

3. **Use in Code**:
   ```rust
   #[cfg(feature = "database")]
   use rust_test::database::{DatabaseRepository, BacktestResult};
   
   let pool = DatabaseRepository::create_pool(&database_url).await?;
   let repo = DatabaseRepository::new(pool);
   repo.insert_backtest_result(&result).await?;
   ```

### Integration Points
- **investor_demo.rs**: Automatically saves backtest results to PostgreSQL if `DATABASE_URL` is set
- **Repository Pattern**: All database operations go through `DatabaseRepository`
- **Type Safety**: Uses `rust_decimal::Decimal` for financial calculations (avoids floating-point errors)
- **Query Helpers**: Query structs (`TickQuery`, `OHLCVQuery`, `BacktestQuery`) for flexible filtering

### Known Issues & Solutions
1. **sqlx rust_decimal support**: Requires `rust_decimal` feature `db-postgres` and `sqlx` feature `rust_decimal`
2. **FromRow for complex tuples**: Use intermediate structs with `#[derive(FromRow)]` instead of large tuples
3. **thiserror dependency**: Must be added to `Cargo.toml` for `RepositoryError`
4. **Feature flags**: Always compile with `--features gate_exec,database` when using database functionality

### Next Steps
- [ ] Fix compilation errors in `repository.rs` (FromRow, thiserror imports)
- [ ] Add migration support (sqlx migrate)
- [ ] Implement connection pooling configuration
- [ ] Add transaction support for batch operations
- [ ] Create database health check endpoint

## HFT Backtest Engine Implementation

### Core Features (‚úÖ Completed)
- **Tick-by-Tick Simulation**: –ö–∞–∂–¥—ã–π —Ç–∏–∫ –æ–±—Ä–∞–±–∞—Ç—ã–≤–∞–µ—Ç—Å—è –æ—Ç–¥–µ–ª—å–Ω–æ —Å –º–∏–ª–ª–∏—Å–µ–∫—É–Ω–¥–Ω–æ–π —Ç–æ—á–Ω–æ—Å—Ç—å—é
- **Full Order Book (L2/L3)**: –ü–æ–ª–Ω–∞—è —Ä–µ–∫–æ–Ω—Å—Ç—Ä—É–∫—Ü–∏—è —Å—Ç–∞–∫–∞–Ω–∞ —Å –æ—á–µ—Ä–µ–¥—è–º–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
  - –ü–æ–¥–¥–µ—Ä–∂–∫–∞ —Å–∫—Ä—ã—Ç—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤ –∏ –∞–π—Å–±–µ—Ä–≥–æ–≤
  - FIFO/ProRata/TimePriority –º–æ–¥–µ–ª–∏ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏—è
- **Latency Modeling**: –°–ª—É—á–∞–π–Ω—ã–µ –∑–∞–¥–µ—Ä–∂–∫–∏ —Å–µ—Ç–∏ (10-20 –º—Å) –¥–ª—è —Ä–µ–∞–ª–∏—Å—Ç–∏—á–Ω–æ–≥–æ –º–æ–¥–µ–ª–∏—Ä–æ–≤–∞–Ω–∏—è
- **Order Fill Simulation**: –£—á–µ—Ç –ø–æ–∑–∏—Ü–∏–∏ –≤ –æ—á–µ—Ä–µ–¥–∏, —á–∞—Å—Ç–∏—á–Ω–æ–µ –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ
- **Monte Carlo**: –ú–Ω–æ–≥–æ–∫—Ä–∞—Ç–Ω—ã–µ –ø—Ä–æ–≥–æ–Ω—ã –¥–ª—è —Å—Ç–∞—Ç–∏—Å—Ç–∏–∫–∏ —Å—Ç–∞–±–∏–ª—å–Ω–æ—Å—Ç–∏
- **.bin Format**: –°–æ–≤–º–µ—Å—Ç–∏–º–æ—Å—Ç—å —Å MoonBot —Ñ–æ—Ä–º–∞—Ç–æ–º –¥–∞–Ω–Ω—ã—Ö

### Market Filters (‚úÖ Completed)
- –î–µ–ª—å—Ç–∞ —Ñ–∏–ª—å—Ç—Ä—ã: 1–º, 3–º, 5–º, 15–º, 30–º, 1—á, 24—á –æ–∫–Ω–∞
- –û–±—ä–µ–º–Ω—ã–µ —Ñ–∏–ª—å—Ç—Ä—ã: 24—á –æ–±—ä–µ–º, –ª–∏–∫–≤–∏–¥–Ω–æ—Å—Ç—å, –≤–æ–ª–∞—Ç–∏–ª—å–Ω–æ—Å—Ç—å
- –§–∏–ª—å—Ç—Ä —Å—Ç–∞–≤–∫–∏ —Ñ–∏–Ω–∞–Ω—Å–∏—Ä–æ–≤–∞–Ω–∏—è
- –§–∏–ª—å—Ç—Ä—ã —à–∞–≥–∞ —Ü–µ–Ω—ã –∏ –º–∞—Ä–∫ –ø—Ä–∞–π—Å–∞
- –¢–æ–ø-N —Ä—ã–Ω–∫–æ–≤ –ø–æ –∫—Ä–∏—Ç–µ—Ä–∏—é (Volume24h, Delta1h, Volatility, Liquidity)

### Strategy Rating System (‚úÖ Completed)
- **Profitability Score** (0-10): –ö–æ–º–±–∏–Ω–∞—Ü–∏—è P&L, profit factor, win rate
- **Stability Score** (0-10): Sharpe ratio
- **Risk Score** (0-10): –û–±—Ä–∞—Ç–Ω—ã–π max drawdown
- **Fill Rate Score** (0-10): –ü—Ä–æ—Ü–µ–Ω—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–Ω—ã—Ö –æ—Ä–¥–µ—Ä–æ–≤
- **Overall Rating** (0-10): –°—Ä–µ–¥–Ω–µ–≤–∑–≤–µ—à–µ–Ω–Ω–æ–µ (35% profit, 25% stability, 25% risk, 15% fill rate)
- **Stars** (0-5): –ê–≤—Ç–æ–º–∞—Ç–∏—á–µ—Å–∫–æ–µ –ø—Ä–∏—Å–≤–æ–µ–Ω–∏–µ –Ω–∞ –æ—Å–Ω–æ–≤–µ overall rating

### Module Structure
```
src/backtest/
‚îú‚îÄ‚îÄ engine.rs           # –û—Å–Ω–æ–≤–Ω–æ–π –¥–≤–∏–∂–æ–∫ –±—ç–∫—Ç–µ—Å—Ç–∞
‚îú‚îÄ‚îÄ orderbook.rs        # L2/L3 —Å—Ç–∞–∫–∞–Ω —Å –æ—á–µ—Ä–µ–¥—è–º–∏
‚îú‚îÄ‚îÄ emulator.rs         # –≠–º—É–ª—è—Ç–æ—Ä —Ä—ã–Ω–∫–∞
‚îú‚îÄ‚îÄ market.rs           # TradeTick, TradeStream
‚îú‚îÄ‚îÄ filters.rs          # –§–∏–ª—å—Ç—Ä—ã –∏ —Å–µ–ª–µ–∫—Ç–æ—Ä—ã
‚îú‚îÄ‚îÄ metrics.rs          # –ú–µ—Ç—Ä–∏–∫–∏ –∏ —Ä–µ–π—Ç–∏–Ω–≥
‚îú‚îÄ‚îÄ replay.rs           # Replay –¥–≤–∏–∂–æ–∫
‚îú‚îÄ‚îÄ bin_format.rs       # –ß—Ç–µ–Ω–∏–µ/–∑–∞–ø–∏—Å—å .bin —Ñ–∞–π–ª–æ–≤
‚îú‚îÄ‚îÄ delta_calculator.rs # –ö–∞–ª—å–∫—É–ª—è—Ç–æ—Ä –¥–µ–ª—å—Ç (15m, 1h, 3h, BTC, Market)
‚îî‚îÄ‚îÄ strategy_adapter.rs # –ê–¥–∞–ø—Ç–µ—Ä —Å—Ç—Ä–∞—Ç–µ–≥–∏–π –¥–ª—è –±—ç–∫—Ç–µ—Å—Ç–µ—Ä–∞
```

## MoonBot Strategies Implementation

### Status
- ‚úÖ **MShot**: –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å–æ –≤—Å–µ–º–∏ –ø–∞—Ä–∞–º–µ—Ç—Ä–∞–º–∏ (MShotPrice, MShotPriceMin, –¥–µ–ª—å—Ç—ã, –ø–æ–≤—Ç–æ—Ä—ã, Repeat)
- ‚úÖ **MStrike**: –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å LastBidEMA –ø–æ —Ñ–æ—Ä–º—É–ª–µ MoonBot, –¥–µ—Ç–µ–∫—Ç –ø—Ä–æ—Å—Ç—Ä–µ–ª–∞, MStrikeWaitDip
- ‚úÖ **Hook**: –ü–æ–ª–Ω–∞—è —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è —Å –¥–∏–Ω–∞–º–∏—á–µ—Å–∫–∏–º –∫–æ—Ä–∏–¥–æ—Ä–æ–º, 5 —Ä–µ–∂–∏–º–æ–≤ –∏–Ω—Ç–µ—Ä–ø–æ–ª—è—Ü–∏–∏, BuyOrderReduce
- üöß **Spread**: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –≥–æ—Ç–æ–≤–∞, –Ω—É–∂–Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è –∞–∫—Ç–∏–≤–Ω—ã—Ö –∑–æ–Ω
- üöß **EMA Filter**: –°—Ç—Ä—É–∫—Ç—É—Ä–∞ –≥–æ—Ç–æ–≤–∞, –Ω—É–∂–Ω–∞ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏—è CustomEMA —Ñ–æ—Ä–º—É–ª
- üöß **Triggers**: –°–∏—Å—Ç–µ–º–∞ —Ç—Ä–∏–≥–≥–µ—Ä–æ–≤ –¥–ª—è –∞–∫—Ç–∏–≤–∞—Ü–∏–∏ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
- üöß **Sessions**: –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ —Å–µ—Å—Å–∏—è–º–∏ —Å –ø—Ä–æ—Ñ–∏—Ç–æ–º/—É–±—ã—Ç–∫–æ–º

### Strategy Location
–í—Å–µ MoonBot —Å—Ç—Ä–∞—Ç–µ–≥–∏–∏ –Ω–∞—Ö–æ–¥—è—Ç—Å—è –≤ `src/strategy/moon_strategies/`

### Strategy Integration
- ‚úÖ **StrategyAdapter trait**: –£–Ω–∏—Ñ–∏—Ü–∏—Ä–æ–≤–∞–Ω–Ω—ã–π –∏–Ω—Ç–µ—Ä—Ñ–µ–π—Å –¥–ª—è –∏–Ω—Ç–µ–≥—Ä–∞—Ü–∏–∏ —Å –±—ç–∫—Ç–µ—Å—Ç–µ—Ä–æ–º
- ‚úÖ **MShotAdapter, MStrikeAdapter, HookAdapter**: –ì–æ—Ç–æ–≤—ã –∫ –∏—Å–ø–æ–ª—å–∑–æ–≤–∞–Ω–∏—é
- ‚úÖ **–ò–Ω—Ç–µ–≥—Ä–∞—Ü–∏—è –≤ BacktestEngine**: –°—Ç—Ä–∞—Ç–µ–≥–∏–∏ –ø–æ–¥–∫–ª—é—á–µ–Ω—ã —á–µ—Ä–µ–∑ –∞–¥–∞–ø—Ç–µ—Ä—ã –≤ `recalculate_strategies`
- ‚úÖ **DeltaCalculator**: –†–µ–∞–ª—å–Ω–æ–µ –≤—ã—á–∏—Å–ª–µ–Ω–∏–µ –¥–µ–ª—å—Ç –∏–∑ –∏—Å—Ç–æ—Ä–∏–∏ —Ç–∏–∫–æ–≤ (15m, 1h, 3h, BTC, Market)
- ‚úÖ **Unit Tests**: –î–æ–±–∞–≤–ª–µ–Ω—ã —Ç–µ—Å—Ç—ã –¥–ª—è MStrike –∏ Hook —Å—Ç—Ä–∞—Ç–µ–≥–∏–π

## API Endpoints Status

### ‚úÖ Implemented
- `GET /` - –ì–ª–∞–≤–Ω–∞—è —Å—Ç—Ä–∞–Ω–∏—Ü–∞
- `GET /api/strategies` - –°–ø–∏—Å–æ–∫ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
- `GET /api/leverages` - –°–ø–∏—Å–æ–∫ –ø–ª–µ—á
- `GET /api/symbols` - –°–ø–∏—Å–æ–∫ —Å–∏–º–≤–æ–ª–æ–≤
- `POST /api/backtest` - –ó–∞–ø—É—Å–∫ –±—ç–∫—Ç–µ—Å—Ç–∞
- `GET /api/results` - –†–µ–∑—É–ª—å—Ç–∞—Ç—ã –±—ç–∫—Ç–µ—Å—Ç–æ–≤

### üìã Planned (see docs/API_ENDPOINTS.md)
- Auth endpoints (register, login, me)
- CRUD –¥–ª—è —Å—Ç—Ä–∞—Ç–µ–≥–∏–π
- –£–ø—Ä–∞–≤–ª–µ–Ω–∏–µ API –∫–ª—é—á–∞–º–∏
- –ó–∞—è–≤–∫–∏ –∫–ª–∏–µ–Ω—Ç–æ–≤
- Live —Ç–æ—Ä–≥–æ–≤–ª—è
- WebSocket –¥–ª—è —Å—Ç—Ä–∏–º–∏–Ω–≥–∞

## Testing Checklist

### Before Committing
- [x] `cargo check --features gate_exec` - –±–µ–∑ –æ—à–∏–±–æ–∫ ‚úÖ
- [x] `cargo test` - –≤—Å–µ —Ç–µ—Å—Ç—ã –ø—Ä–æ—Ö–æ–¥—è—Ç ‚úÖ
- [x] File size < 1200 lines (–∂–µ–ª–∞—Ç–µ–ª—å–Ω–æ < 800) ‚úÖ
- [x] No unused imports/variables (fix warnings) ‚úÖ
- [x] Documentation –¥–ª—è public APIs ‚úÖ

### Integration Tests
- [ ] Backtest engine —Ä–∞–±–æ—Ç–∞–µ—Ç —Å —Ä–µ–∞–ª—å–Ω—ã–º–∏ –¥–∞–Ω–Ω—ã–º–∏
- [ ] OrderBook –ø—Ä–∞–≤–∏–ª—å–Ω–æ —Å–∏–º—É–ª–∏—Ä—É–µ—Ç –∏—Å–ø–æ–ª–Ω–µ–Ω–∏–µ
- [ ] –ú–µ—Ç—Ä–∏–∫–∏ –∫–æ—Ä—Ä–µ–∫—Ç–Ω–æ —Ä–∞—Å—Å—á–∏—Ç—ã–≤–∞—é—Ç—Å—è
- [ ] –†–µ–π—Ç–∏–Ω–≥ —Å—Ç—Ä–∞—Ç–µ–≥–∏–π —Ä–∞–±–æ—Ç–∞–µ—Ç

## Performance Targets

- **Backtest Speed**: > 100,000 —Ç–∏–∫–æ–≤/—Å–µ–∫
- **OrderBook Updates**: < 1–º—Å –Ω–∞ —Ç–∏–∫
- **Memory Usage**: < 2GB –¥–ª—è 1M —Ç–∏–∫–æ–≤
- **API Response Time**: < 100–º—Å –¥–ª—è –±–æ–ª—å—à–∏–Ω—Å—Ç–≤–∞ endpoints

## Documentation Files

- `docs/HFT_BACKTEST_SPEC.md` - –ü–æ–ª–Ω–∞—è —Å–ø–µ—Ü–∏—Ñ–∏–∫–∞—Ü–∏—è HFT –±—ç–∫—Ç–µ—Å—Ç–µ—Ä–∞
- `docs/API_ENDPOINTS.md` - –î–æ–∫—É–º–µ–Ω—Ç–∞—Ü–∏—è –ø–æ API
- `docs/CHECKLIST.md` - –ß–µ–∫–ª–∏—Å—Ç —Ä–∞–∑—Ä–∞–±–æ—Ç–∫–∏
- `IMPLEMENTATION_SUMMARY.md` - –ò—Ç–æ–≥–∏ —Ä–µ–∞–ª–∏–∑–∞—Ü–∏–∏

## Strategy Rating System (Strat Ninja Style)

### Overview
Create a comprehensive strategy rating and ranking system similar to https://strat.ninja/ with:
- Multiple tabs (Latest, Failed, Private, DCA, Multiclass, Ranking)
- Detailed metrics and filtering
- Modern UI/UX with dark/light theme
- Real-time updates and auto-refresh
- Strategy details modal/page with visualizations

### Implementation Plan (Step-by-Step)

#### Step 1: Data Structure & Backend API
**Location**: `freqtrade/rating_api_server.py` (FastAPI backend)

**Tasks**:
- Extend existing API endpoints to support tabs:
  - `/api/rankings/latest` - Latest backtests
  - `/api/rankings/failed` - Failed backtests with reasons
  - `/api/rankings/private` - Private strategies (no URL)
  - `/api/rankings/dca` - DCA-enabled strategies
  - `/api/rankings/multiclass` - Multiclass strategies
  - `/api/rankings/main` - Main ranking (default, filtered)
- Add query parameters:
  - `exchange` (binance, kucoin, gateio)
  - `stake` (USDT, BUSD, BTC)
  - `hide_negative` (boolean)
  - `show_dca` (boolean)
  - `show_multiclass` (boolean)
  - `sort_by` (ninja_score, avg_prof, tot_profit, win_rate, sharpe)
  - `order` (asc, desc)
- Return data structure:
```json
{
  "data": [
    {
      "strategy_name": "ElliotV5_SMA",
      "avg_buys": 27,
      "avg_prof": 0.58,
      "avg_tot_profit_pct": 2.73,
      "avg_win_pct": 75.67,
      "avg_dd_pct": 4.47,
      "timeframe": "5m",
      "stoploss": -0.189,
      "avg_sharpe": 1.91,
      "ninja_score": 62,
      "exchange": "gateio",
      "stake": "USDT",
      "flags": {
        "lookahead": false,
        "private": false,
        "futures": false,
        "tight_trailing": false,
        "dca": false,
        "multiclass": false
      },
      "backtests": [
        {
          "month": "202507",
          "buys": 32,
          "avg_prof": 1.56,
          "tot_profit_pct": 11.5,
          "win_pct": 84.4,
          "dd_pct": 6.89,
          "sharpe": 5.31
        }
      ]
    }
  ],
  "total": 152,
  "filtered": 7
}
```

#### Step 2: Frontend - Tabs & Table Structure
**Location**: `freqtrade/user_data/web/rating_ui.html`

**Tasks**:
- Create tab navigation:
  ```html
  <div class="tabs">
    <button class="tab active" data-tab="ranking">Ranking</button>
    <button class="tab" data-tab="latest">Latest</button>
    <button class="tab" data-tab="failed">Failed</button>
    <button class="tab" data-tab="private">Private</button>
    <button class="tab" data-tab="dca">DCA</button>
    <button class="tab" data-tab="multiclass">Multiclass</button>
  </div>
  ```
- Table columns (exact match to strat.ninja):
  - Strategy (clickable, opens details)
  - avg Buys
  - avg Prof%
  - avg Tot Profit%
  - avg Win%
  - avg DD%
  - TF (timeframe)
  - Stoploss
  - avg Sharpe
  - Ninja Score (with percentage bar)
- Add flags column with icons:
  - L = Lookahead bias
  - P = Private / No URL
  - F = Futures
  - T = Tight Trailing Stop
  - D = DCA enabled
  - M = Multiclass
- Implement sorting (clickable headers)
- Add pagination (Show 12/25/50/100 rows)

#### Step 3: Filters & Search Panel
**Tasks**:
- Exchange filter (dropdown): All Exchanges, Binance, Kucoin, Gate.io
- Instrument filter (radio/tabs): [Spot] USDT / BUSD / BTC
- Futures toggle: [Futures] USDT
- Checkboxes:
  - ‚òê Hide Negative
  - ‚òê Hide Private
  - ‚òê Show Multiclass
  - ‚òê Show DCA
- Search input: Filter by strategy name
- Apply/Reset buttons

#### Step 4: Auto-Update & Real-time
**Tasks**:
- Auto-refresh every 30-60 seconds
- Show loading indicators during updates
- Smooth transitions (fade in/out)
- WebSocket support (optional, for live updates)
- Notification system for new backtests

#### Step 5: Strategy Details Modal/Page
**Tasks**:
- Click on strategy name ‚Üí open modal or navigate to detail page
- Show detailed information:
  - Strategy name, hash (SHA256)
  - Indicators list (with importance/impact)
  - Backtests breakdown by month (table)
  - Equity curve chart (Plotly.js or Chart.js)
  - Recursive Analysis results
  - Comments section
  - Similar strategies (based on indicators)
- Charts:
  - Equity curve (cumulative profit over time)
  - Monthly performance bar chart
  - Win/Loss distribution
  - Drawdown visualization

#### Step 6: Stats Dashboard
**Tasks**:
- Create stats section (updated hourly):
  - Total Strategies: XXXX
  - Github Strategies: XXXX
  - Uploaded Strategies: XXXX
  - Total Backtests: (XXXXX)
  - Quantstats Generated: (XXXX)
  - Failed Testing: XX% (XXXX)
  - Duplicate: XX% (XXXX)
  - Lookahead: XX% (XXXX)
  - Tight Trailing: XX% (XXXX)
  - Biased Strategies: XX% (XXXX)
  - Stalled: XX% (XXXX)
  - Private: XX% (XXXX)
  - DCA: XX% (XXXX)
  - Multiclass: XX% (XXXX)
  - Backtest/Month: XX% (XXXX)
- Backtesting progress by exchange:
  - Binance Spot: XX% (X)
  - Kucoin Spot: XX% (X)
  - Binance Futures: XX% (X)
- Latest Backtests list
- Latest Failed Backtests list
- Latest Uploads list

#### Step 7: UI/UX Enhancements
**Tasks**:
- Dark/Light theme toggle (save preference in localStorage)
- Modern design:
  - Smooth animations
  - Hover effects
  - Loading skeletons
  - Toast notifications
  - Responsive layout (mobile-friendly)
- Color coding:
  - Green for positive metrics
  - Red for negative metrics
  - Yellow/Orange for warnings
  - Gray for neutral/disabled
- Progress indicators:
  - Ninja Score as percentage bar
  - Win rate as progress bar
  - Drawdown as negative progress bar

#### Step 8: Data Processing & Metrics
**Location**: `freqtrade/strategy_rating_system_standalone.py`

**Tasks**:
- Calculate monthly breakdown from backtest results
- Group backtests by month
- Calculate averages (avg Buys, avg Prof, etc.)
- Calculate Ninja Score using weighted formula:
  ```
  ninja_score = (
    buys * 9 +
    avg_prof * 26 +
    tot_prof_pct * 26 +
    win_pct * 24 +
    dd_pct * -25 +
    stoploss * 7 +
    sharpe * 7 +
    sortino * 7 +
    calmar * 7 +
    expectancy * 8 +
    profit_factor * 9 +
    cagr * 10 +
    rejected_signals * -25 +
    backtest_win_pct * 10
  )
  ```
- Detect flags:
  - Lookahead bias (via analysis)
  - Private (no download URL)
  - Futures (can_short = True)
  - Tight Trailing Stop (trailing_stop_positive <= 0.0025)
  - DCA (position_adjustment_enable = True)
  - Multiclass (multiple classes in file)

#### Step 9: API Endpoints Implementation
**Tasks**:
```python
@app.get("/api/rankings/{tab}")
async def get_rankings_tab(
    tab: str,  # latest, failed, private, dca, multiclass, main
    exchange: Optional[str] = None,
    stake: Optional[str] = None,
    hide_negative: bool = False,
    show_dca: bool = False,
    show_multiclass: bool = False,
    sort_by: str = "ninja_score",
    order: str = "desc",
    page: int = 1,
    per_page: int = 12
):
    """Get rankings for specific tab with filters"""
    # Implementation here
```

#### Step 10: Testing & Optimization
**Tasks**:
- Test with 1000+ strategies
- Optimize API queries (indexing, caching)
- Test all filters combinations
- Test pagination
- Test sorting on all columns
- Performance: < 100ms API response, smooth UI updates
- Mobile responsiveness testing

### Code Style for Rating System
- Use consistent naming: `avg_buys`, `avg_prof`, `tot_profit_pct`, `win_pct`, `dd_pct`
- Store all backtests per strategy (not just medians) for monthly breakdown
- Use TypeScript-like type hints in Python for clarity
- Implement proper error handling and fallbacks
- Use async/await for all API calls
- Cache API responses where appropriate (client-side)
- Use localStorage for user preferences (theme, filters, pagination)

### File Organization
```
freqtrade/
‚îú‚îÄ‚îÄ rating_api_server.py          # Main API server
‚îú‚îÄ‚îÄ strategy_rating_system_standalone.py  # Data processing
‚îú‚îÄ‚îÄ rating_web_interface_standalone.py   # HTML generator (legacy)
‚îî‚îÄ‚îÄ user_data/
    ‚îî‚îÄ‚îÄ web/
        ‚îú‚îÄ‚îÄ rating_ui.html        # Main UI (modern, with tabs)
        ‚îú‚îÄ‚îÄ strategy_detail.html  # Strategy detail page (optional)
        ‚îî‚îÄ‚îÄ assets/
            ‚îú‚îÄ‚îÄ style.css         # Styles (dark/light theme)
            ‚îî‚îÄ‚îÄ app.js            # JavaScript logic
```

### References
- Strat Ninja: https://strat.ninja/
- Freqtrade Backtesting: https://www.freqtrade.io/en/stable/backtesting/
- Plotly.js: https://plotly.com/javascript/
- Material UI: https://mui.com/
- Ant Design: https://ant.design/

## References
- Rust Async Book: https://rust-lang.github.io/async-book/
- Tokio Documentation: https://tokio.rs/
- Rust API Guidelines: https://rust-lang.github.io/api-guidelines/
- Rust Error Index: https://doc.rust-lang.org/error_codes/
- Barter-rs: https://github.com/barter-rs/barter-rs
- Rust-trade: See `rust-trade/README.md`
- MoonBot Documentation: See strategy specs in code comments
